/*
 *  Copyright (C) 2024, MARVELL. All rights reserved.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License"); you may
 *    not use this file except in compliance with the License. You may obtain
 *    a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *    THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR
 *    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
 *    LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS
 *    FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
 *
 *    See the Apache Version 2.0 License for specific language governing
 *    permissions and limitations under the License.
 *
 */

#include <h/poe_v3.h>
#include <h/utils/dictionary.h>
#include <h/utils/lock.h>
#include <PDLIB/h/pdlib/lib/private/prvPdlLib.h>
#include <PDLIB/parser/pdlParser.h>
#include <PDLIB/h/pdlib/init/pdlInit.h>
#include <PDLIB/h/pdlib/lib/pdlLib.h>
#include <h/utils/log.h>

static PDL_FEATURE_DATA_STC        *board_info_db_ptr;
static XML_PARSER_ROOT_DESCRIPTOR_TYP   xml_root_id;

/* global databases */
Dictionary *device_db_ptr = NULL, *pse_db_ptr = NULL, *port_db_ptr = NULL;
poe_v3_msg_sysPowerBank_STC power_bank_list = {0};
/* lock critical sections when reading/writing */
rwlock_excl_t lock;

static void xpSaiPdlibDebugCallback(const char *func_name_ptr,
                                    const char *format, ...)
{
    va_list     argptr;
    char        log[1024];
    int         len;

    snprintf(log, sizeof(len), "pdlib debug: [%s]", func_name_ptr);
    len = strlen(log);
    vsnprintf(&log[len], sizeof(log) - len, format, argptr);
}

static  BOOLEAN xpSaiPdlibXmlUncompressCallback(
    IN  char       *archiveFileNamePtr,
    OUT char       *xmlFileNamePtr,
    OUT char       *signatureFileNamePtr
)
{
    char * ch, *xml = xmlFileNamePtr, *sig = signatureFileNamePtr;
    for (ch = archiveFileNamePtr; ch != NULL && *ch != '\0'; ch++, xml++, sig++)
    {
        if (*ch != '.')
        {
            *xml = *sig = *ch;
        }
        else
        {
            strcpy(xml, ".xml");
            strcpy(sig, ".md5");

            return TRUE;
        }
    }

    return FALSE;
}

/*
 * This is a call back routine registed with Pdlib used for
 * checking the sanity of the Xml generated by Ezb Tool.
 * i.e manually editing xml with ezb tool is not allowed.
 *
 * xmlFileNamePtr : contains the path of the xml file.
 * signatureSize  : Size of the Signature.
 * signaturePtr   : return the Md5 generated by Application
 *                  for validation by pdlib
 */

static  BOOLEAN xpSaiPdlibgetXmlSignatureCallback(
    IN  char       *xmlFileNamePtr,
    IN  UINT_32     signatureSize,
    OUT UINT_8     *signaturePtr
)
{
    FILE *xml_fd;
    UINT_32 file_size, i, len=0;
    PDL_LIB_MD5_DIGEST_STC md5_digest;

    /*
     * This Secret which has to match with the one provided
     * in the Ezb tool.
     * PDL_LIB_MD5_DIGEST_LENGTH_CNS:16
     */
    UINT_8 xpSaiSignature[]="";
    char step2CombinedStr[(PDL_LIB_MD5_DIGEST_LENGTH_CNS * 2) + sizeof(
                                                                  xpSaiSignature)] = {0};

    xml_fd = fopen(xmlFileNamePtr, "rb");
    if (!xml_fd)
    {
        return FALSE;
    }

    /* Md5 calculation is 2 step process
     * Step 1: Calculate Md5 on Xml content
     * Step 2: Add the secret key to the Md5 generated in Step 1,
     *         and then generate final Md5
     */
    fseek(xml_fd, 0L, SEEK_END);
    file_size=ftell(xml_fd);
    fseek(xml_fd, 0L, SEEK_SET);
    // Step 1:
    pdlibMd5DigestCompute(&xml_fd, NULL, file_size, &md5_digest);
    fclose(xml_fd);

    /* convert numeric digest to text */
    for (i = 0 ; i < PDL_LIB_MD5_DIGEST_LENGTH_CNS; i++)
    {
        len+=sprintf(&step2CombinedStr[len], "%02x", md5_digest.value[i]);
    }

    //len+=sprintf(&step2CombinedStr[len], "%s", xpSaiSignature);

    //Step 2:
    pdlibMd5DigestCompute(NULL, (UINT_8*)&step2CombinedStr[0],
                          strlen(step2CombinedStr), &md5_digest);

    memcpy(signaturePtr, &md5_digest, signatureSize);

    return TRUE;
}

bool board_info_db_get_first (
    /*!     INPUTS:             */
    PRV_PDLIB_DB_TYP  dbHandler,
    /*!     INPUTS / OUTPUTS:   */
    /*!     OUTPUTS:            */
    void                    **outEntryPtrPtr
)
{
/*!****************************************************************************/
/*! L O C A L   D E C L A R A T I O N S   A N D   I N I T I A L I Z A T I O N */
/*!****************************************************************************/
    PDL_STATUS status;
/*!****************************************************************************/
/*!                      F U N C T I O N   L O G I C                          */
/*!****************************************************************************/

    status = prvPdlibDbGetFirst (dbHandler, outEntryPtrPtr);

    if (status == PDL_NOT_FOUND)
    {
        return FALSE;
    }
    else if (status != PDL_OK)
    {
        return FALSE;
    }

    return TRUE;
}

bool  board_info_db_get_next (
    /*!     INPUTS:             */
    PRV_PDLIB_DB_TYP  dbHandler,
    void                    *keyPtr,
    /*!     INPUTS / OUTPUTS:   */
    /*!     OUTPUTS:            */
    void                    **outEntryPtrPtr
)
{
/*!****************************************************************************/
/*! L O C A L   D E C L A R A T I O N S   A N D   I N I T I A L I Z A T I O N */
/*!****************************************************************************/
    PDL_STATUS status;
/*!****************************************************************************/
/*!                      F U N C T I O N   L O G I C                          */
/*!****************************************************************************/
    status = prvPdlibDbGetNext((PRV_PDLIB_DB_TYP)dbHandler, keyPtr, outEntryPtrPtr);

    if(status == PDL_OK) {
        return TRUE;
    }

    return FALSE;
}

bool board_info_db_num_of_entries_get (
    /*!     INPUTS:             */
    PRV_PDLIB_DB_TYP  dbHandler,
    /*!     INPUTS / OUTPUTS:   */
    /*!     OUTPUTS:            */
    UINT_32                *numOfEntriesPtr
)
{
/*!****************************************************************************/
/*! L O C A L   D E C L A R A T I O N S   A N D   I N I T I A L I Z A T I O N */
/*!****************************************************************************/
    PDL_STATUS status;
/*!****************************************************************************/
/*!                      F U N C T I O N   L O G I C                          */
/*!****************************************************************************/

    status = prvPdlibDbGetNumOfEntries(dbHandler, numOfEntriesPtr);

    if (status != PDL_OK)
    {
        return FALSE;
    }

    return TRUE;
}

/**
 * @brief initialize a database for each of the objects (device/pse/port)
 *
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t database_initialize() 
{
    uint64_t key;
    uint32_t num_of_entries = 1, index = 0;
    PDL_PSE_LIST_PARAMS_STC *pse_list_ptr = NULL;
    PDL_PSEPORT_LIST_PARAMS_STC *pse_port_list_ptr = NULL;
    PDL_POEBANK_LIST_PARAMS_STC *power_banks_list_ptr = NULL;
    bool get_next = TRUE;
    poe_op_result_t result = poe_op_ok_E;
    
    /* create dictionary for the poe device */
    device_db_ptr = create_dictionary(num_of_entries);
    if(!device_db_ptr) {
        result = poe_op_failed_E;
        LOG_ERROR("failed to create poe device dictionary");
        goto exit;
    }
    
    /* set key value and update dictionary, there will be one poe device object */
    poe_device_db_t *device_db_entry_ptr = (poe_device_db_t*)malloc(sizeof(poe_device_db_t));
    
    if(!device_db_entry_ptr) {
        result = poe_op_failed_E;
        LOG_ERROR("failed to read NULL entry");
        goto exit;
    }

    key = device_db_entry_ptr->device_id = 0;

    if(!dict_put(device_db_ptr, key, (void*)(device_db_entry_ptr))) {
        result = poe_op_failed_E;
        LOG_ERROR("failed to insert into poe device dictionary");
        goto exit;
    }

    /* get the number of pse devices, and create the dictionary for the poe pse list */
    if(!board_info_db_num_of_entries_get(board_info_db_ptr->data_PTR->poe.pselist.pseList_PTR, &num_of_entries)) {
        result = poe_op_failed_E;
        LOG_ERROR("failed to get num of entries");
        goto exit;
    }

    pse_db_ptr = create_dictionary(num_of_entries);
    if(!pse_db_ptr) {
        result = poe_op_failed_E;
        LOG_ERROR("failed to create poe pse dictionary");
        goto exit;
    }

    /* get hw data */
    get_next = board_info_db_get_first(board_info_db_ptr->data_PTR->poe.pselist.pseList_PTR, (void **)&pse_list_ptr);

    /* for each pse, set key value and update dictionary */
    while(get_next) {
        poe_pse_db_t *pse_db_entry_ptr = (poe_pse_db_t*)malloc(sizeof(poe_pse_db_t));

        if(!pse_db_entry_ptr) {
            result = poe_op_failed_E;
            LOG_ERROR("failed to read NULL entry");
            goto exit;
        }
        
        key = pse_db_entry_ptr->pse_id = pse_list_ptr->list_keys.pseNumber;

        if(!dict_put(pse_db_ptr, key, (void*)(pse_db_entry_ptr))) {
            result = poe_op_failed_E;
            LOG_ERROR("failed to insert into poe device dictionary");
            goto exit;
        }

        /* get hw data */
        get_next = board_info_db_get_next(board_info_db_ptr->data_PTR->poe.pselist.pseList_PTR, (void *)&pse_list_ptr->list_keys, (void **)&pse_list_ptr);
    }

    /* get the number of poe ports, and create the dictionary for the poe port list */
    if(!board_info_db_num_of_entries_get(board_info_db_ptr->data_PTR->poe.pseports.pseportList_PTR, &num_of_entries)) {
        result = poe_op_failed_E;
        LOG_ERROR("failed to get num of entries");
        goto exit;
    }

    port_db_ptr = create_dictionary(num_of_entries);
    if(!port_db_ptr) {
        result = poe_op_failed_E;
        LOG_ERROR("failed to create poe port dictionary");
        goto exit;
    }

    if(!board_info_db_num_of_entries_get(board_info_db_ptr->data_PTR->poe.pselist.pseList_PTR, &num_of_entries)) {
        result = poe_op_failed_E;
        LOG_ERROR("failed to get num of entries");
        goto exit;
    }

    /* get hw data */
    get_next = board_info_db_get_first(board_info_db_ptr->data_PTR->poe.pseports.pseportList_PTR, (void **)&pse_port_list_ptr);

    /* for each port, set key value and update dictionary */
    while(get_next) {
        poe_port_db_t *port_db_entry_ptr = (poe_port_db_t*)malloc(sizeof(poe_port_db_t));

        if(!port_db_entry_ptr) {
            result = poe_op_failed_E;
            LOG_ERROR("failed to read NULL entry");
            goto exit;
        }

        key = port_db_entry_ptr->front_panel_index = pse_port_list_ptr->list_keys.frontPanelPortIndex;
        switch (pse_port_list_ptr->portType) {
            case PDL_PSEPORT_TYPE_AT_E:
                port_db_entry_ptr->port_standard = poe_port_hw_type_at_E;
                break;
            case PDL_PSEPORT_TYPE_BT_TYPE3_E:
                port_db_entry_ptr->port_standard = poe_port_hw_type_bt_type3_E;
                break;
        }

        port_db_entry_ptr->physical_index_a = pse_port_list_ptr->index1;
        port_db_entry_ptr->physical_index_b = pse_port_list_ptr->index2;

        if(!dict_put(port_db_ptr, key, (void*)(port_db_entry_ptr))) {
            result = poe_op_failed_E;
            LOG_ERROR("failed to insert into poe device dictionary");
            goto exit;
        }

        /* get hw data */
        get_next = board_info_db_get_next(board_info_db_ptr->data_PTR->poe.pseports.pseportList_PTR, (void *)&pse_port_list_ptr->list_keys, (void **)&pse_port_list_ptr);
    }

    /* get the number of power banks, and update the power bank list */
    if(!board_info_db_num_of_entries_get(board_info_db_ptr->data_PTR->poe.poePowerBanks.poebankList_PTR, &num_of_entries)) {
        result = poe_op_failed_E;
        LOG_ERROR("failed to get num of entries");
        goto exit;
    }

    /* get hw data */
    get_next = board_info_db_get_first(board_info_db_ptr->data_PTR->poe.poePowerBanks.poebankList_PTR, (void **)&power_banks_list_ptr);

    /* for each pse, set key value and update the array */
    while(get_next) {
        power_bank_list.power_bank_w_swap[power_banks_list_ptr->list_keys.bankNumber] = power_banks_list_ptr->bankWatts;

        /* get hw data */
        get_next = board_info_db_get_next(board_info_db_ptr->data_PTR->poe.poePowerBanks.poebankList_PTR, (void *)&power_banks_list_ptr->list_keys, (void **)&power_banks_list_ptr);
    }

exit:
    return result;
}

/**
 * @brief General initialize a for the shared memory protocol
 *
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t shared_memory_initialize() {
    return poe_op_ok_E;
}

/**
 * @brief Initialize board info, to receive board specific parameters
 *
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t board_info_initialize() {
    char            profile_file[100];
    char            file_name[100];
    PDL_STATUS                                      status;
    XML_PARSER_ROOT_DESCRIPTOR_TYP                  xml_root;
    PDLIB_OS_CALLBACK_API_STC                        callbacks;
    char                                           *base_name_ptr, base_name[256],
                                                   full_path[256] = "/local/store/sai-poe/sai_poe_library/board_info/rdac5xpoe.xml";
    strcpy(base_name, full_path);
    base_name_ptr = dirname(base_name);
    
    /* Project_profile Init */
    memset(&callbacks, 0, sizeof(callbacks));
    callbacks.printStringPtr       = printf;
    callbacks.mallocPtr            = malloc;
    callbacks.freePtr              = free;
    callbacks.debugLogPtr          = xpSaiPdlibDebugCallback;
    callbacks.arXmlUncompressClbk = xpSaiPdlibXmlUncompressCallback;
    callbacks.getXmlSignatureClbk = xpSaiPdlibgetXmlSignatureCallback;

    status = pdlibInit((char *)full_path, (char *)"saiplt", &callbacks, &xml_root);
    if(status != PDL_OK) {
        LOG_ERROR("failed to initialize pdlib");
        return poe_op_failed_E;
    }

    status = prvPdlCodeParser(xml_root);
    if(status != PDL_OK) {
        LOG_ERROR("failed to initialize code parser");
        return poe_op_failed_E;
    }

    status = prvPdlFeaturesDataHandler();
    if(status != PDL_OK) {
        LOG_ERROR("failed to set feature data handler");
        return poe_op_failed_E;
    }

    status = prvPdlFeaturesDataGet(&board_info_db_ptr);
    if(status != PDL_OK) {
        LOG_ERROR("failed to get feature data");
        return poe_op_failed_E;
    }

    return poe_op_ok_E;
}

/**
 * @brief General initialize for all the PoE components
 *
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_initialize(void) {
    
    poe_op_result_t result = poe_op_ok_E;
    /* init sempahore */
    rwlock_excl_init(&lock);

    rwlock_excl_acquire(&lock);

    /* init board info (from external db) */
    result = board_info_initialize();
    
    if(result != poe_op_ok_E) {
        LOG_ERROR("failed to initialize board info");
        goto exit;
    }

    /* init databases */
    result = database_initialize();
    if(result != poe_op_ok_E) {
        LOG_ERROR("failed to initialize databases");
        goto exit;
    }

    /* set poe port matrix */
    result = poe_port_matrix_initialize();
    if(result != poe_op_ok_E) {
        LOG_ERROR("failed to initialize port matrix");
        goto exit;
    }

    /* set poe port standard */
    result = poe_port_standard_initialize();
    if(result != poe_op_ok_E) {
        LOG_ERROR("failed to initialize port standard");
        goto exit;
    }

    /* set poe power banks */
    result = poe_power_bank_initialize();
    if(result != poe_op_ok_E) {
        LOG_ERROR("failed to initialize power");
        goto exit;
    }

    /* init shared memory */
    result = shared_memory_initialize();
    if(result != poe_op_ok_E) {
        LOG_ERROR("failed to initialize shared memory");
        goto exit;
    }

exit:
    rwlock_excl_release(&lock);
    return result;
}

/**
 * @brief Get the first front panel index
 *
 * @param[out] first_front_panel_index first front panel index
 * 
 * @return #true if operation is successful otherwise false
 *
 */
bool poe_port_get_first_index(uint32_t *first_front_panel_index) {
    KeyValuePair key_value;
    if(!dict_get_first(port_db_ptr, &key_value)) {
        return false;
    }

    *first_front_panel_index = key_value.key;
    return true;
}

/**
 * @brief Get the next front panel index
 *
 * @param[out] front_panel_index next front panel index
 * 
 * @return #true if operation is successful otherwise false
 *
 */
bool poe_port_get_next_index(uint32_t *front_panel_index) {
    KeyValuePair next_key_value;
    
    if(!dict_get_next(port_db_ptr, (uint64_t)(*front_panel_index), &next_key_value)) {
        return false;
    }

    *front_panel_index = next_key_value.key;
    return true;
}

/**
 * @brief Get the poe port hardware type
 *
 * @param[in] front_panel_index front panel index
 * 
 * @return #poe_port_hw_type_t if operation is successful otherwise poe_port_hw_type_invalid_E
 *
 */
poe_port_hw_type_t poe_get_port_poe_hw_type(uint32_t front_panel_index) { 
    poe_port_db_t *value_ptr = (poe_port_db_t*)dict_get(port_db_ptr, (uint64_t)front_panel_index);

    if(value_ptr == NULL) {
        return poe_port_hw_type_invalid_E;
    }

    return value_ptr->port_standard;
}

/**
 * @brief Get the physical port index
 *
 * @param[in] front_panel_index front panel index
 * @param[out] physical_index physical port index
 * 
 * @return #true if operation is successful otherwise false
 *
 */
bool poe_port_get_physical_index(uint32_t front_panel_index, uint32_t *physical_index) {
    poe_port_db_t *value_ptr = (poe_port_db_t*)dict_get(port_db_ptr, (uint64_t)front_panel_index);

    if(value_ptr == NULL) {
        return false;
    }

    *physical_index = value_ptr->physical_index_a;

    return true;
}

/**
 * @brief Get the second physical port index (if it exists)
 *
 * @param[in] front_panel_index front panel index
 * @param[out] physical_index second physical port index
 * 
 * @return #true if operation is successful otherwise false
 *
 */
bool poe_port_get_second_physical_index(uint32_t front_panel_index, uint32_t *physical_index) {
    poe_port_db_t *value_ptr = (poe_port_db_t*)dict_get(port_db_ptr, (uint64_t)front_panel_index);

    if(value_ptr == NULL) {
        return false;
    }

    *physical_index = value_ptr->physical_index_b;

    return true;
}

/**
 * @brief Send/recieve data from the shared memory protocol
 *
 * @param[in] send true if writing data otherwise reading
 * @param[in] op_code operation code
 * @param[in] data_len data length
 * @param[out] data data
 * 
 * @return #true if operation is successful otherwise false
 *
 */
bool EXTHWG_POE_IPc_send_recieve_msg(bool send, uint32_t op_code, uint8_t data_len, uint8_t *data) {
    /* should be implemented in the IPC/shared memory logic */
    return true;
}

/**
 * @brief send/receive message to/from the poe firmware
 *
 * @param[in] msg_level message level (port/system)
 * @param[in] direction get or set
 * @param[in] msg_id message id
 * @param[in] data_len data length
 * @param[out] data_ptr data
 * 
 * @return #true if operation is successful otherwise false
 *
 */
poe_op_result_t poe_v3_send_receive_msg (

    /*!     INPUTS:             */    
    poe_v3_msg_level_TYP        msg_level,
    poe_v3_msg_direction_TYP    direction,
    uint16_t                                 msg_id,
    uint8_t                                  data_len,
    /*!     INPUTS / OUTPUTS:   */
    void*                                   data_ptr
    /*!     OUTPUTS:            */
)
{
/*!****************************************************************************/
/*! L O C A L   D E C L A R A T I O N S   A N D   I N I T I A L I Z A T I O N */
/*!****************************************************************************/
    uint8_t  *buf_ptr;
    bool send=(direction==poe_v3_msg_dir_get_CNS)?false:true;
    poe_v3_msg_opCode_UNT op_code;
/*!****************************************************************************/
/*!                      F U N C T I O N   L O G I C                          */
/*!****************************************************************************/   
    poe_v3_set_msg_opCode_MAC(op_code, msg_level, direction, msg_id);
    buf_ptr = (uint8_t*)data_ptr;
    if (true != EXTHWG_POE_IPc_send_recieve_msg(send, op_code.op_code_num_32, data_len, buf_ptr)) {
        LOG_ERROR("failed to send/recieve poe message, msg id %d, direction %d, op code: %d, level %d", msg_id, direction, op_code.op_code_num_32, msg_level);
        return poe_op_failed_E;
    }

    /* TEMP - return 11 for all data  */
    memset(data_ptr, 11, sizeof(uint8_t));

    return poe_op_ok_E;
} 

/**
 * @brief Intialize port matrix
 * 
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_port_matrix_initialize() {
    uint32_t                          physical_number_a, physical_number_b, front_panel_index, index = 0;
    poe_port_hw_type_t               poe_port_hw_type;
    poe_v3_msg_sysPortMatrix_STC set_matrix_params;
    bool get_next = true;

    /* clean matrix params */
    memset(&set_matrix_params, 0xff, sizeof(poe_v3_msg_sysPortMatrix_STC));
    
    /* for every front panel (logical) poe port in the device, set the correct physical port */
    if(!poe_port_get_first_index(&front_panel_index)) {
        LOG_ERROR("failed to get first index");
        return poe_op_failed_E;
    }

    while (get_next) {

        poe_port_hw_type = poe_get_port_poe_hw_type(front_panel_index);

        if(poe_port_hw_type == poe_port_hw_type_invalid_E) {
            LOG_ERROR("failed to get valid poe type");
            return poe_op_failed_E;
        }

         if(!poe_port_get_physical_index(front_panel_index, &physical_number_a)) {
            LOG_ERROR("failed to get physical index");
            return poe_op_failed_E;
         }

        set_matrix_params.physic_logical_pair[index].logical_port = (uint8_t)front_panel_index;
        set_matrix_params.physic_logical_pair[index++].phys_port = (uint8_t)physical_number_a;
                
        /* if the port supports two channels, set the second physical port */
        if ((poe_port_hw_type == poe_port_hw_type_60W_E) ||
            (poe_port_hw_type == poe_port_hw_type_bt_type3_E) ||
            (poe_port_hw_type == poe_port_hw_type_bt_type4_E)) {
            
            if(!poe_port_get_second_physical_index(front_panel_index, &physical_number_b)) {
                LOG_ERROR("failed to get second index");
                return poe_op_failed_E;
            }

            set_matrix_params.physic_logical_pair[index].logical_port = (uint8_t)front_panel_index;
            set_matrix_params.physic_logical_pair[index++].phys_port = (uint8_t)physical_number_b;
        }

        get_next = poe_port_get_next_index(&front_panel_index);
    }
    
    if (index) {
        return poe_v3_send_receive_msg(
            poe_v3_msg_level_system_CNS, 
            poe_v3_msg_dir_set_CNS,
            poe_v3_sys_msg_portMatrix_CNS,
            sizeof(set_matrix_params),
            (uint8_t*)&set_matrix_params);
    } 

    LOG_ERROR("failed to get entries");
    return poe_op_failed_E;
}

/**
 * @brief intialize port standard
 * 
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_port_standard_initialize() {
    uint32_t                          front_panel_index, index = 0;
    poe_port_hw_type_t      poe_port_hw_type, system_hw_capability;
    poe_v3_msg_sysPortSupportedStd_STC port_standard_params;
    poe_op_result_t status;
    bool get_next = true;

    memset(&port_standard_params, 0xff, sizeof(poe_v3_msg_sysPortSupportedStd_STC));
    
    if(!poe_port_get_first_index(&front_panel_index)) {
        LOG_ERROR("failed to get first index");
        return poe_op_failed_E;
    }

    while (get_next) {
        
        poe_port_hw_type = poe_get_port_poe_hw_type(front_panel_index);
        
        port_standard_params.supported_std_data[index].logic_port = (uint8_t)front_panel_index;
        port_standard_params.supported_std_data[index++].portSupportedStd = poe_port_hw_type;

        get_next = poe_port_get_next_index(&front_panel_index);
    }

    return poe_v3_send_receive_msg(
            poe_v3_msg_level_system_CNS, 
            poe_v3_msg_dir_set_CNS,
            poe_v3_sys_msg_portSupportStandard_CNS,
            sizeof(port_standard_params),
            (uint8_t*)&port_standard_params);
}

/**
 * @brief intialize power banks
 * 
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_power_bank_initialize() {
    uint32_t index = 0;
    poe_v3_msg_sysPowerBank_STC power_bank_params;

    for (index = 0; index < poe_max_num_of_powerBanks_CNS ; index++) {
        power_bank_params.power_bank_w_swap[index] = swap16(power_bank_list.power_bank_w_swap[index]); 
    }
    
    return poe_v3_send_receive_msg(
            poe_v3_msg_level_system_CNS, 
            poe_v3_msg_dir_set_CNS,
            poe_v3_sys_msg_powerBankConfig_CNS,
            sizeof(power_bank_params),
            (uint8_t*)&power_bank_params);
}

/**
 * @brief Get the total system power
 * 
 * @param[in] poe_dev_num device number
 * @param[out] total_power_mw_ptr total power in milliwatts
 * 
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_dev_get_total_power (
    /*!     INPUTS:             */
    UINT_32 poe_dev_num, 
    UINT_32 *total_power_mw_ptr
)
{
    poe_v3_msg_sysPowerConsumption_STC power_consumption_params;
    poe_op_result_t result; 

    if(total_power_mw_ptr == NULL) {
        LOG_ERROR("invalid pointer");
        return poe_op_failed_E;
    }

    rwlock_excl_acquire(&lock); 
    
    *total_power_mw_ptr = power_bank_list.power_bank_w_swap[0];

    rwlock_excl_release(&lock);
    
    return result;
}

/**
 * @brief Get the power consumption
 * 
 * @param[in] poe_dev_num device number
 * @param[out] total_power_mw_ptr active power consumption in milliwatts
 * 
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_dev_get_power_consumption (
    /*!     INPUTS:             */
    UINT_32 poe_dev_num, 
    UINT_32 *power_consumption_mw_ptr
)
{
    poe_v3_msg_sysPowerConsumption_STC power_consumption_params;
    poe_op_result_t result; 

    if(power_consumption_mw_ptr == NULL) {
        LOG_ERROR("invalid pointer");
        return poe_op_failed_E;
    }

    rwlock_excl_acquire(&lock); 
    
    memset(&power_consumption_params, 0, sizeof(power_consumption_params));
    result = poe_v3_send_receive_msg(poe_v3_msg_level_system_CNS, poe_v3_msg_dir_get_CNS, poe_v3_sys_msg_powerConsumption_CNS, sizeof(power_consumption_params), (UINT_8*)&power_consumption_params);

    if(result == poe_op_ok_E) {
        *power_consumption_mw_ptr = (swap32(power_consumption_params.powerConsumption_swap)) + 0.5;
    }
    else {
        LOG_ERROR("failed to get data");
    }

    rwlock_excl_release(&lock);
    
    return result;
}

/**
 * @brief Get the system version (firmware)
 * 
 * @param[in] poe_dev_num device number
 * @param[out] version_ptr frimware version
 * 
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_dev_get_version (
    /*!     INPUTS:             */
    UINT_32 poe_dev_num, 
    char *version_ptr
)
{
    poe_v3_msg_sysSystemVersion_STC *version_params_ptr;
    poe_op_result_t result; 

    if(version_ptr == NULL) {
        LOG_ERROR("invalid pointer");
        return poe_op_failed_E;
    }

    rwlock_excl_acquire(&lock); 

    memset(version_params_ptr, 0, sizeof(poe_v3_msg_sysSystemVersion_STC));
    memset(version_params_ptr->pse_version_data, 0xFF, sizeof(version_params_ptr->pse_version_data));
    result = poe_v3_send_receive_msg(poe_v3_msg_level_system_CNS, poe_v3_msg_dir_get_CNS, poe_v3_sys_msg_systemVersion_CNS, sizeof(*version_params_ptr), (uint8_t*)version_params_ptr);

    if(result == poe_op_ok_E) {
        snprintf (version_ptr, 20, "%d.%d.%d.%d", 
                    version_params_ptr->poeFwVersion.ver_bytes[0],
                    version_params_ptr->poeFwVersion.ver_bytes[1],
                    version_params_ptr->poeFwVersion.ver_bytes[2], 
                    version_params_ptr->poeFwVersion.ver_bytes[3]);
    }
    else {
        LOG_ERROR("failed to get data");
    }

    rwlock_excl_release(&lock);

    return result;
}

/**
 * @brief Get power limit mode (class/port limit)
 * 
 * @param[in] poe_dev_num device number
 * @param[out] power_limit_ptr power limit
 * 
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_dev_get_power_limit_mode (
    /*!     INPUTS:             */
    uint32_t poe_dev_num, 
    uint32_t *power_limit_ptr
)
{
    poe_v3_msg_sysPowerLimitMode_STC limit_mode_params;
    poe_op_result_t result; 

    if(power_limit_ptr == NULL) {
        LOG_ERROR("invalid pointer");
        return poe_op_failed_E;
    }

    rwlock_excl_acquire(&lock); 

    memset(&limit_mode_params, 0, sizeof(poe_v3_msg_sysPowerLimitMode_STC));

    result = poe_v3_send_receive_msg(poe_v3_msg_level_system_CNS, poe_v3_msg_dir_get_CNS, poe_v3_sys_msg_systemVersion_CNS, sizeof(limit_mode_params), (uint8_t*)&limit_mode_params);

    if(result == poe_op_ok_E) {
        *power_limit_ptr = (uint32_t)limit_mode_params.limit_mode;
    }
    else {
        LOG_ERROR("failed to get data");
    }

    rwlock_excl_release(&lock);
    
    return result;
}

/**
 * @brief Get power limit mode (class/port limit)
 * 
 * @param[in] poe_dev_num device number
 * @param[out] power_limit_ptr power limit
 * 
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_dev_set_power_limit_mode (
    /*!     INPUTS:             */
    uint32_t poe_dev_num, 
    uint32_t power_limit_ptr
)
{
    poe_v3_msg_sysPowerLimitMode_STC limit_mode_params;
    poe_op_result_t result; 

    if(power_limit_ptr == NULL) {
        LOG_ERROR("invalid pointer");
        return poe_op_failed_E;
    }

    rwlock_excl_acquire(&lock); 

    memset(&limit_mode_params, 0, sizeof(poe_v3_msg_sysPowerLimitMode_STC));
    limit_mode_params.limit_mode = (poe_v3_powerLimitMode_TYP)power_limit_ptr;

    result = poe_v3_send_receive_msg(poe_v3_msg_level_system_CNS, poe_v3_msg_dir_set_CNS, poe_v3_sys_msg_systemVersion_CNS, sizeof(limit_mode_params), (uint8_t*)&limit_mode_params);

    if(result != poe_op_ok_E) {
        LOG_ERROR("failed to get data");
    }

    rwlock_excl_release(&lock);
    
    return result;
}

/**
 * @brief Set enable/disable on poe port
 * 
 * @param[in] front_panel_index front panel index
 * @param[in] enable enable/disable
 * 
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_port_set_admin_enable (
    uint32_t front_panel_index,
    const bool enable
)
{
    poe_v3_msg_portEnable_STC   port_params;
    poe_op_result_t result; 

    rwlock_excl_acquire(&lock); 

    memset(&port_params, 0, sizeof(poe_v3_msg_portEnable_STC));
    port_params.logic_port_num = (uint8_t)front_panel_index;
    port_params.port_admin_enable_disable = (enable==true)?poe_v3_port_admin_enable_CNS:poe_v3_port_admin_disable_CNS;

    result = poe_v3_send_receive_msg(poe_v3_msg_level_port_CNS, poe_v3_msg_dir_set_CNS, poe_v3_port_msg_portEnable_CNS, sizeof(port_params), (uint8_t*)&port_params);

    if(result != poe_op_ok_E) {
        LOG_ERROR("failed to set data");
    }

    rwlock_excl_release(&lock);

    return result;
} 

/**
 * @brief get poe port enable/disable state
 * 
 * @param[in] front_panel_index front panel index
 * @param[out] enable enable/disable
 * 
 * @return #poe_op_ok_E if operation is successful otherwise a different
 *    error code is returned.
 */
poe_op_result_t poe_port_get_admin_enable (
    uint32_t front_panel_index,
    bool *enable
)
{
    poe_v3_msg_portEnable_STC   port_params;
    poe_op_result_t result;

    if(enable == NULL) {
        LOG_ERROR("invalid pointer");
        return poe_op_failed_E;
    }

    rwlock_excl_acquire(&lock);  

    memset(&port_params, 0, sizeof(poe_v3_msg_portEnable_STC));
    port_params.logic_port_num = (uint8_t)front_panel_index;

    result = poe_v3_send_receive_msg(poe_v3_msg_level_port_CNS, poe_v3_msg_dir_get_CNS, poe_v3_port_msg_portEnable_CNS, sizeof(port_params), (uint8_t*)&port_params);

    if(result == poe_op_ok_E) {
        *enable = port_params.port_admin_enable_disable;
    }

    rwlock_excl_release(&lock);

    return result;
}

/**
 * @brief swap uint16_t
 * 
 * @param[in] value uint16_t value
 * 
 * @return swapped uint16_t value
 * 
 */
uint16_t swap16(uint16_t value) {
    return (value << 8) | (value >> 8);
}

/**
 * @brief swap uint32_t
 * 
 * @param[in] value uint32_t value
 * 
 * @return swapped uint32_t value
 * 
 */
uint32_t swap32(uint32_t value) {
    return ((value & 0xFF000000) >> 24) |     // Move byte 3 to byte 0
           ((value & 0x00FF0000) >> 8)  |     // Move byte 2 to byte 1
           ((value & 0x0000FF00) << 8)  |     // Move byte 1 to byte 2
           ((value & 0x000000FF) << 24);      // Move byte 0 to byte 3
}


/* TEMP - main() moved to sai_poe for the sai menu options */
// void main() {
//     poe_initialize();
// }